<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Modern Javascript on the Browser</title>

		<link rel="icon" type="image/svg+xml" href="./assets/logo.svg">

		<meta name="description" content="A Presentation on using ES6+ features for the Browser">
		<meta name="author" content="Rohit Siddheshwar">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="./dist/reset.css">
		<link rel="stylesheet" href="./dist/reveal.css">
		<link rel="stylesheet" href="./dist/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/main.css">

		<!-- Theme used for syntax highlighting of code -->
		<!-- <link rel="stylesheet" href="./plugin/highlight/monokai.css" id="highlight-theme"> -->
		<link rel="stylesheet" href="./css/night-owl.css" id="highlight-theme">
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h3>Modern Javascript on the Browser</h3>
				</section>

				<section>
					<h2>Why are we here?</h2>
					<ul>
						<li class="fragment">Understand Modern Javascript</li>
						<li class="fragment">Understanding the challenges to serve Modern Javascript</li>
						<li class="fragment">How to serve it across all browsers</li>
					</ul>
				</section>

				<section>
					<h2>What will we do here?</h2>
					<h3 class="fragment">Part 1</h3>
					<ul>
						<li class="fragment">
							ES6 and above - ES6, ES7, ES8, ES9, ES10 and ES11
							<br>
							<small class="fragment">Skim through basic features. Will talk more on the interesting ones not used by us till now</small>
							<small class="fragment"> Will also look at some interesting parts of ES12 proposed spec (by tc39).</small>
						</li>
					</ul>
					<h3 class="fragment">Part 2</h3>
					<ul>
						<li class="fragment">Modularising your JS</li>
						<li class="fragment">Application Bundling and serving</li>
					</ul>
				</section>

				<section data-transition="slide-in zoom-out">
					<h1>Lets begin PART 1!</h1>
				</section>

				<section>
					<h2>Overview</h2>
					<div class="rgs-container">
						<div class="rgs-block">Variables and Scopes</div>
						<div class="rgs-block">Default Parameters</div>
						<div class="rgs-block">Destructuring Assignments</div>
						<div class="rgs-block">Strings and Literals</div>
						<div class="rgs-block">Enhanced Object Properties</div>
						<div class="rgs-block">Classes and OOP</div>
						<div class="rgs-block">Symbols</div>
						<div class="rgs-block">Collections</div>
						<div class="rgs-block">Loops and Iterables</div>
						<div class="rgs-block">Generators</div>
						<div class="rgs-block">Newly Introduced Operators</div>
						<div class="rgs-block">New Built-ins</div>
						<div class="rgs-block">Asynchronous Programming</div>
						<div class="rgs-block">Meta Programming</div>
					</div>
				</section>

				<!-- Variables and scopes -->
				<section>
					<section>
						<h2>Variables and Scopes</h2>
					</section>

					<section>
						<b class="varcolor">const</b>
						<div class="fragment">
							<h2>ES 5</h2>
							<pre data-id="const-es5-slide">
								<code class="JavaScript" data-trim data-line-numbers>
									var PI = 3.142;
									PI = 5; // allowed
								</code>
							</pre>
						</div>
						<div class="fragment">
							<h2>ES 6</h2>
							<pre data-id="const-slide">
								<code class="JavaScript" data-trim data-line-numbers>
									const PI = 3.142;
									PI = 5; // Error - cannot redeclare a const
								</code>
							</pre>
						</div>
					</section>

					<section>
						<b class="varcolor">let</b>
						<div class="fragment">
							<h2>ES 5</h2>
							<pre data-id="let-es5-slide">
								<code class="JavaScript" data-trim data-line-numbers>
									console.log(x);// undefined
									var x = 5;
									console.log(x);// 5
								</code>
							</pre>
						</div>
						<div class="fragment">
							<h2>ES 6</h2>
							<pre data-id="let-es6-slide">
								<code class="JavaScript" data-trim data-line-numbers>
									console.log(x);// error - x is not defined
									let x = 5;
									console.log(x);
								</code>
							</pre>
						</div>
					</section>

					<section>
						<p>Scope of <b class="varcolor">let</b></p>
						<div class="fragment">
							<p><b class="varcolor">var</b> has a function scope</p>
							<pre data-id="let-scope-slide">
								<code class="JavaScript" data-trim data-line-numbers>
									function test() {
										// i is declared as var
										for (var i = 0; i < 10; i++) {
											...
										}
										console.log(i);// 10
									}
									test();
								</code>
							</pre>
						</div>
					</section>

					<section>
						<pre data-id="let-scope-slide-2">
							<code class="JavaScript" data-trim data-line-numbers>
								function test() {
									// i is declared as let
									for (let i = 0; i < 10; i++) {
										...
									}
									console.log(i);// error - i is not defined
								}
								test();
							</code>
						</pre>
						<div class="fragment">
							<p>Block scope</p>
						</div>
					</section>

					<section>
						<h2>Blocks</h2>
						<div class="fragment">
							<pre data-id="block-slide">
								<code class="JavaScript" data-trim data-line-numbers="1,10|2|3,8|6|7|9">
									function test() {
										let x = 10;
										{
											// this is a block
											// can do some operation without polluting parent scope
											let x = 20;
											console.log(x);// 20
										}
										console.log(x);// 10
									}
									test();
								</code>
							</pre>
						</div>
					</section>
					<section>
						<p>Works with functions also</p>
						<p>Blocked Scoped Functions</p>
						<pre data-id="block-slide-2">
							<code class="JavaScript" data-trim data-line-numbers="2,3|5-8|10">
								function test() {
									function foo () { return 1; }
									console.log(foo()); // 1

									{
										function foo () { return 2; }
										console.log(foo()); // 2
									}

									console.log(foo()); // 1
								}
								test();
							</code>
						</pre>
					</section>

					<section>
						<h2>Arrow Functions</h2>
						<div class="fragment">
							<h2>ES 5</h2>
							<pre data-id="func-es5-slide">
								<code class="JavaScript" data-trim data-line-numbers>
									var func = function (a) {return a+1;};
									console.log(func(1));// 2
								</code>
							</pre>
						</div>
						<div class="fragment">
							<h2>ES 6</h2>
							<pre data-id="func-es6-slide">
								<code class="JavaScript" data-trim data-line-numbers>
									const func = a => a+1;
									console.log(func(1));// 2
								</code>
							</pre>
						</div>
					</section>
					<section>
						<h2>Anatomy of the Arrow function</h2>
						<div class="fragment">
							<pre data-id="func-anatomy-slide">
								<code class="JavaScript" data-trim data-line-numbers="1|3,4|6,7">
									let variable = (a, b, c) => {return a + b + c;};

									// if we are just returning a value, we can avoid brackets and return keyword
									let variable = (a, b, c) => a + b + c;

									// for single arguement, we can avoid paranthesis as well
									let variable = a => a + 1;
								</code>
							</pre>
						</div>
					</section>
					<section>
						<p><b>Scopes in Arrow Functions</b></p>
						<div class="fragment">
							<p>In ES5, we would do this to maintain proper context in callbacks</p>
							<pre data-id="func-scope-slide">
								<code class="JavaScript" data-trim data-line-numbers="1,12|3|4|5,11|6,10|2,9">
									function dummy(numbers) {
										var instance = this;// to use current context inside callbacks
										this.nums = numbers;
										this.fives = [];
										this.nums.forEach(function (v) {
											if (v % 5 === 0) {
												// if this was used, it will take the current
												// function context instead of dummy's
												instance.fives.push(v);
											}
										});
									}
									var x = new dummy([1,2,3,4,5,6,7,8,9,10]);
									console.log(x.fives);// [5, 10]
								</code>
							</pre>
						</div>
					</section>
					<section>
						<p>Arrow functions are executed in the declaration context rather than the calling context</p>
						<pre data-id="func-scope-slide-2">
							<code class="JavaScript" data-trim data-line-numbers="2,9">
								function dummy(numbers) {
									// No need of instance
									this.nums = numbers;
									this.fives = [];

									this.nums.forEach(v => {
										if (v % 5 === 0) {
											// this refers to dummy's instance
											this.fives.push(v);
										}
									});
								}
								var x = new dummy([1,2,3,4,5,6,7,8,9,10]);
								console.log(x.fives);// [5, 10]
							</code>
						</pre>
					</section>
				</section>

				<!-- Default Parameters -->
				<section>
					<section>
						<h2>Default Parameters</h2>
					</section>

					<section>
						<p>Function params can have default values</p>
						<pre data-id="defaults-slide">
							<code class="JavaScript" data-trim data-line-numbers="1">
								function increment(base, by = 1) {// default values to params
									return base + by;
								}
								console.log(increment(2, 4));// 6
								console.log(increment(2));// 3
							</code>
						</pre>
					</section>

					<section>
						<p>Spread Operator</p>
						<pre class="fragment" data-id="defaults-slide">
							<code class="JavaScript" data-trim data-line-numbers="2">
								const str = "abcde";
								const chars = [...str];// ['a','b','c','d','e']
							</code>
						</pre>
					</section>
					<section>
						<p>is very usefull for appending or prepending an array or concatinating 2 arrays</p>
						<pre class="fragment" data-id="defaults-slide">
							<code class="JavaScript" data-trim data-line-numbers="2">
								const arr1 = [1,2,3,4];
								const arr2 = [0, ...arr1];
							</code>
							<code class="JavaScript" data-trim data-line-numbers="2">
								const arr1 = [1,2,3,4];
								const arr2 = [...arr1, 5];
							</code>
							<code class="JavaScript" data-trim data-line-numbers="3">
								const arr1 = [1,2,3,4];
								const arr2 = [5,6,7,8];
								const arr3 = [...arr1, ...arr2];
							</code>
						</pre>
					</section>

					<section>
						<p>A positive outcome of using the spread operator is that it helps make your code have immutable variables.</p>
					</section>

					<section>
						<p>Rest parameter</p>
						<p class="fragment">add x and y and multiply by number of arguements other than x and y</p>
						<p class="fragment">ES5</p>
						<pre class="fragment" data-id="defaults-slide">
							<code class="JavaScript" data-trim data-line-numbers="|2">
								function func (x, y) {
									var a = Array.prototype.slice.call(arguments, 2);
									return (x + y) * a.length;
								}
								console.log(func(1, 2, "hello", true, 7));// 9
							</code>
						</pre>
					</section>
					<section>
						<p>ES6</p>
						<pre data-id="defaults-slide">
							<code class="JavaScript" data-trim data-line-numbers="|2|3">
								// "..." if used to collect elements is called a rest
								function func (x, y, ...a) {
									return (x + y) * a.length;
								}
								console.log(func(1, 2, "hello", true, 7));// 9
							</code>
						</pre>
					</section>
				</section>

				<!-- Destructuring Assignments -->
				<section>
					<section>
						<h2>Destructuring Assignments</h2>
					</section>

					<section>
						<b>Array and Object Assignments!!</b>
						<pre data-id="obj-slide">
							<code class="JavaScript" data-trim data-line-numbers="|2,4">
								const [a, b] = [1,2];
								console.log(a, b); // 1, 2
								const {x, y} = {x: 1, y: 2};
								console.log(x, y); // 1, 2
							</code>
						</pre>
					</section>

					<section data-background-iframe="https://es6console.com/" data-background-interactive>
					</section>
				</section>

				<!-- Strings and Literals -->
				<section>
					<section>
						<h2>Strings and Literals</h2>
					</section>

					<section>
						<h2>Template Literals</h2>
						<pre data-id="literals-slide">
							<code class="JavaScript" data-trim data-line-numbers="|2">
								const data = "test";
								console.log(`we are logging via a variable : ${data}`);
								// we are logging via a variable : test
							</code>
						</pre>
					</section>

					<section data-background-iframe="https://es6console.com/" data-background-interactive>
					</section>

					<section>
						<b>Extended Literals</b>
						<pre data-id="literals-slide">
							<code class="JavaScript" data-trim data-line-numbers="|1,2">
								let binaryNumber = 0b111110111;
								let octal = 0o767;
								console.log(binaryNumber);// 503
								console.log(octal);// 503
							</code>
						</pre>
					</section>

					<section>
						<b>Unicodes in Strings and Regexes</b>
						<pre data-id="literals-slide">
							<code class="JavaScript" data-trim data-line-numbers>
								console.log("𠮷".length === 2);// true
								console.log("𠮷".match(/./u)[0].length === 2);// true
							</code>
						</pre>
					</section>
				</section>

				<!-- Enhanced Object Properties -->
				<section>
					<section>
						<h2>Enhanced Object Properties</h2>
					</section>

					<section>
						<b>Shorthand properties in objects</b>
						<pre data-id="obj-slide">
							<code class="JavaScript" data-trim data-line-numbers="|6-10">
								function getPerson(n, s, a) {
									const name = n;
									const surname = s;
									const age = a;
									// no need to write key name if key name and variable name is the same
									return {
										name,
										surname,
										age, // trailing commas are allowed now!
									};
								}
								const p = getPerson("Jonas", "Kahnwald", NaN);
								console.log(p.name);// Jonas
							</code>
						</pre>
					</section>

					<section>
						<b>Property names can be dynamic while defining</b>
						<div class="fragment">
							<b>ES5 way to have computed property names</b>
							<pre data-id="obj-slide">
								<code class="JavaScript" data-trim data-line-numbers="|4">
									var obj = {
										foo: "bar"
									};
									obj[ "baz" + fn() ] = 42;
								</code>
							</pre>
						</div>

					</section>

					<section>
						<b>ES6</b>
						<pre data-id="obj-slide">
							<code class="JavaScript" data-trim data-line-numbers>
								const obj = {
									foo: "bar",
									["baz" + fn()]: 42,
								};
							</code>
						</pre>
					</section>

					<section>
						<b>Method Properties</b>
						<pre data-id="obj-slide">
							<code class="JavaScript" data-trim data-line-numbers>
								const obj = {
									foo() {
										// need not write foo: function () {}
									}
								};
							</code>
						</pre>
					</section>
					
				</section>

				<!-- Classes and OOP -->
				<section>
					<section>
						<h2>Classes and OOP</h2>
					</section>

					<section>
						<b>The ES5 Way</b>
						<pre data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers="|4">
								var MyClass = function () {
									//constructor
								};
								Shape.prototype.publicMethod = function () {};
								var ob = new MyClass();
								ob.publicMethod();
							</code>
						</pre>
						<pre data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers="|5">
								function MyClass() {

									_constructor() {}
								
									this.publicMethod = function () {};

									_constructor();
								}

								var ob = new MyClass();
								ob.publicMethod();
							</code>
						</pre>
					</section>

					<section>
						<b>The ES6 Way</b>
						<pre data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers="|1-8">
								class MyClass {
									constructor () {

									}
									publicMethod () {

									}
								}

								const ob = new MyClass();
								ob.publicMethod();
							</code>
						</pre>
					</section>

					<section>
						<b>Private methods (tc39 proposal for es12 - June 2021)</b>
						<pre data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers="|2,7,10">
								class MyClass {
									#X = 0; // private variables
									constructor () {

									}
									publicMethod () {
										this.#privateMethod();
									}
								
									#privateMethod () {}
								}

								const ob = new MyClass();
								ob.publicMethod();
							</code>
						</pre>
					</section>
						
					<section>
						<b>Inheritence</b>
						<pre data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers="|1">
								class MobileOverlayConfig extends OverlayConfig {
									constructor() {
										super();
									}
									// custom functions here
								}
							</code>
						</pre>
					</section>

					<section>
						<b>Static members</b>
						<pre data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers="|3">
								class MyClass {
									...
									static getNewObj() {
										return new MyClass();
									}
								}
							</code>
						</pre>
					</section>

					<section>
						<b>Getters and Setters</b>
						<pre data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers="|4,5|4,8,10|5,9,11">
								class MyClass {
									constructor() {this._a = 0;}

									set a(aValue) {this._a = aValue * 2;}
									get a() {return this._a % 100;}
								}
								const ob = new MyClass();
								ob.a = 5;
								console.log(ob.a);// 10
								ob.a = 50;
								console.log(ob.a);// 0
							</code>
						</pre>
					</section>
				</section>

				<!-- Symbols -->
				<section>
					<section>
						<h2>Symbols</h2>
					</section>

					<section>
						<b>Unique Immutable data types</b>
						<pre data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers="1|2|3|4">
								const k = Symbol();
								const m = Symbol("named");
								const n = Symbol("named");
								console.log(m == n, m === n); // false, false
							</code>
						</pre>
					</section>

					<section>
						<b>Where can they be used?</b>
						<pre class="fragment" data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers>
								const RED_COLOR = Symbol('red');
								const BLUE_COLOR = Symbol('blue');
								...
								// for internal logic, we can pass around the symbol like an enum
								function getColorCode(color) {
									switch(color) {
										case RED_COLOR:
											return "#FF0000";
										...
									}
								}
							</code>
						</pre>
					</section>

					<section>
						<h2>Console DEMO</h2>
					</section>
				</section>

				<!-- Collections -->
				<section>
					<section>
						<h2>Collections in ES6</h2>
					</section>

					<section>
						<b>Sets</b>
						<p class="fragment">All items are unique</p>
						<pre class="fragment" data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers="|4">
								const set = new Set();
								set.add("A").add("B").add("B");
								console.log(set.size);// 2
								console.log(set.has("A"));// true
							</code>
						</pre>
					</section>

					<section>
						<b>Maps</b>
						<p class="fragment">Better versions of JS Objects to be used foe mapping</p>
						<p class="fragment">Dictionaries!</p>
						<pre class="fragment" data-id="classes-slide">
							<code class="JavaScript" data-trim data-line-numbers="1,2|4-6|8,9|10">
								const map = new Map();
								map.set("Potato", 12);
								
								var key = {a: "a"}
								// works on reference
								map.set(key, 20);

								console.log(map.get("Potato")); //12
								console.log(map.get(key)); //20
								console.log(map.has(key)); //true
							</code>
						</pre>
					</section>

					<section data-background-iframe="https://es6console.com/" data-background-interactive>
					</section>

					<section>
						<h2>CONSOLE DEMO</h2>
					</section>

					<section>
						<h2>WeakSets and WeakMaps</h2>
						<p class = "fragment">They behave the same way like Maps and Sets except</p>
						<ol>
							<li class = "fragment">Non Iterable</li>
							<li class = "fragment">Keys will be objects only</li>
							<li class = "fragment">Weak references will be maintained. Will not stop garbage collection from clearing the weakly referenced object key</li>
						</ol>
					</section>

					<section>
						<a href="./demo/WeakCollections/index.html" target="_blank">
							<b>Demo Link</b>
						</a>
					</section>
				</section>

				<!-- Loops and Iterables -->
				<section>
					<section>
						<h2>
							Loops and Iterables
						</h2>
					</section>

					<section data-transition="slide-in fade-out">
						<h2>Types of loops</h2>
						<ul>
							<li class="fragment">
								<p>for, while, do...while</p>
								<pre data-id="loops-slide">
									<code class="JavaScript" data-trim data-line-numbers="1|3|5">
										for (let i = 0; i < 10; i++) {..code..}

										while (condition) {..code..}

										do {.. code ..} while(condition);
									</code>
								</pre>
							</li>
							<li class="fragment">
								<p>for..in</p>
								<pre data-id="loops-slide">
									<code class="JavaScript" data-trim data-line-numbers="|2">
										const arr = [1,2,3,4,5];
										for (let i in arr) {...}
									</code>
								</pre>
							</li>
						</ul>
					</section>

					<section data-transition="fade-in fade-out">
						<h2>Types of loops</h2>
						<ul>
							<li>
								<p>Arrays.forEach, Map.forEach, Set.forEach</p>
								<pre data-id="loops-slide">
									<code class="JavaScript" data-trim data-line-numbers="|2-4">
										const arr = [1,2,3,4,5];
										arr.forEach((value, index, arrayInstance) => {
											... code ...
										});
									</code>
								</pre>
							</li>
							<li style="visibility: hidden;">
								<pre data-id="loops-slide">
									







									
								</pre>
							</li>
						</ul>
					</section>

					<section data-transition="fade-in fade-out">
						<h2>Types of loops</h2>
						<ul>
							<li>
								<b>for..of <i class="varcolor">(new)</i></b>
								<pre data-id="loops-slide">
									<code class="JavaScript" data-trim data-line-numbers="1|2-4">
										const a = [1,2,3,4,5]
										for (let k of f) {
											console.log(k);
										}
										/*
										OP:
										1
										2
										3
										4
										5
										*/
									</code>
								</pre>
							</li>
							<li style="visibility: hidden;">
								<pre data-id="loops-slide">
									







									
								</pre>
							</li>
						</ul>
					</section>

					<section data-transition="fade-in slide-out">
						<h2>Types of loops</h2>
						<ul>
							<li>
								<b>for..of with Maps</b>
								<pre data-id="loops-slide">
									<code class="JavaScript" data-trim data-line-numbers="|3">
										const map = new Map();
										m.set("a", 1).set("b", 2).set("c", 3).set("d", 4);
										for (let [key, value] of map) {
											console.log(key, value);
										}
									</code>
								</pre>
							</li>
							<li style="visibility: hidden;">
								<pre data-id="loops-slide">
									









									
								</pre>
							</li>
						</ul>
					</section>

					<section>
						<b>Iterators</b>
						<p>JS Objects are inherently not iterable. (Iteration-safe)</p>
						<pre class="fragment" data-id="loops-slide" style="font-size: 16px;">
							<code class="JavaScript" data-trim data-line-numbers="1-4|6|8|11-13|15-20|17">
								function Person(firstName, lastName) {
									this.firstName = firstName;
									this.lastName = lastName;
								}

								Person.prototype.age = Infinity;

								var adam = new Person('Jonas', 'Kahnwald');
							
								// this loop through all properties including the prototype
								for (let trait in adam) {
									console.log(trait, adam[trait]);
								}
	  
								for (let trait in adam) {
									// this loops only through 'own' properties of the object
									if (adam.hasOwnProperty(trait)) {
										console.log(trait, adam[trait]);
									}
								}
							</code>
						</pre>
					</section>

					<section>
						<h2>What is an Iterator?</h2>
						<p class="fragment">Object having the <b class="varcolor">next()</b> function</p>
						<p class="fragment">Capable of generating the NEXT object</p>
						<pre class="fragment" data-id="loops-slide">
							<code class="JavaScript" data-trim data-line-numbers>
								// Iterator
								{
									next() {
										return {
											done: false,// last value should have this as true
											value: ______,
										}
									}
								}
							</code>
						</pre>
					</section>

					<section>
						<b class="varcolor">Symbol.iterator</b>
						<p>This enables us to make any object iterable. i.e. we could use for..of on any object</p>
					</section>

					<section>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="2,10|5,6,7,8|13,17|">
								let fibonacci = {
									[Symbol.iterator]() {
										let pre = 0, cur = 1
										return {
										   next () {
											   [ pre, cur ] = [ cur, pre + cur ]
											   return { done: false, value: cur }
										   }
										}
									}
								}
								
								for (let n of fibonacci) {
									if (n > 1000)
										break
									console.log(n)
								}
							</code>
						</pre>
					</section>

				</section>

				<!-- Generators -->

				<section data-background-iframe="https://es6console.com/ke1m2cm0/" data-background-interactive>
				</section>

				<section>
					<section>
						<h2>Generators</h2>
					</section>

					<section>
						<p>Regular functions return only one, single value (or nothing).</p>
						<p class="fragment">Generators can return multiple values, one after another when asked for.</p>
					</section>

					<section>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1,5|2|3|4|7|8,9,10,11|">
								function* myGen() {
									yield 1;
									yield 2;
									yield 3;
								}

								const g = myGen();
								g.next();//{value: 1, done: false}
								g.next();//{value: 2, done: false}
								g.next();//{value: 3, done: false}
								g.next();//{value: undefined, done: true}
							</code>
						</pre>
					</section>

					<section>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1,5|2|3|4|7|10|">
								function* myGen() {
									yield 1;
									yield 2;
									return 3;
								}

								const g = myGen();
								g.next();//{value: 1, done: false}
								g.next();//{value: 2, done: false}
								g.next();//{value: 3, done: true}
								g.next();//{value: undefined, done: true}
							</code>
						</pre>
					</section>

					<section>
						<p>
							Generators can do more than just iterable stuff.
						</p>
					</section>

					<section data-background-iframe="https://es6console.com/ke1m2cm0/" data-background-interactive>
					</section>

					<section>
						<p>Can be used for</p>
						<ul>
							<li>variable Step iterators</li>
							<li><b>Command line tools:</b> Conditional Questions. (eg: npm init)</li>
							<li>State Machines - Redux Saga</li>
						</ul>
					</section>
				</section>

				<!-- Newly Introduced Operators -->
				<section>
					<section>
						<h2>Newly Introduced Operators</h2>
					</section>

					<section>
						<b>Nullish Coalescing</b>
						<p>for selecting a first “defined” variable</p>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers>

								x = (a !== undefined) ? a : b;

								// instead of this, you could write

								x = a ?? b;
							</code>
						</pre>
					</section>

					<section>
						<p>Due to safety reasons, it’s forbidden to use ?? together with && and || operators.</p>
						<p class="fragment">Because of PRECEDENCE</p>
						<p class="fragment">?? has a higher precedence than logical operators</p>
						<pre class="fragment" data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers>
								let x = 1 && 2 ?? 3;
							</code>
						</pre>
						<p class="fragment">Its added to prevent programming mistakes when people switch from || to ??</p>
					</section>

					<section>
						<b>Optional Chaining</b>
						<p>Used when object is supposed to have optional properties</p>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1,2,3,4|6,7|8|9|10,11">
								const getModule = (name) => {
									if (name === "a") 
										return {a:1};
									return null;
								}

								const m1 = getModule('a');
								const m2 = getModule('b');
								m1.a;// a
								m2.a;// error
								m2?.a;//nothing happens
								// equivalent to m2 && m2.a
							</code>
						</pre>
					</section>
				</section>

				<!-- New Built-ins -->
				<section>
					<section>
						<h2>
							New Built-ins
						</h2>
					</section>

					<section>
						<b>Object.assign</b>
						<p>Used for Shallow Copy of an object</p>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers>
								const target = { a: 1, b: 2 };
								const source = { b: 4, c: 5 };

								const returnedTarget = Object.assign(target, source);

								console.log(target);
								// expected output: Object { a: 1, b: 4, c: 5 }

								console.log(returnedTarget);
								// expected output: Object { a: 1, b: 4, c: 5 }
							</code>
						</pre>
					</section>

					<section data-transition="slide-in fade-out">
						<b>Arrays</b>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1|3|5|7">
								const arr = [5, 12, 8, 130, 44];

								const found = arr.find(element => element > 10);// true

								const foundIndex = arr.findIndex(element => element > 10);// 1

								const isThere = arr.includes(130);// true

							</code>
						</pre>
					</section>

					<section data-transition="fade-in slide-out">
						<b>Arrays</b>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1|3,4|6|8">
								const arr1 = [0, 1, 2, [3, 4]];

								console.log(arr1.flat());
								// expected output: [0, 1, 2, 3, 4]

								const arr2 = [0, 1, 2, [[[3, 4]]]];

								console.log(arr2.flat(2));
							</code>
						</pre>
					</section>

					<section>
						<b>Strings</b>
						<p class="fragment">All functions are immutable</p>
						<pre class="fragment" data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1|3|4|5|6|7|8|9">
								const paani = 'paani ';

								console.log(`Aaj blue hai ${paani.repeat(6)}`);
								console.log(paani.startsWith("pa"));// true
								paani.endsWith("ni", 5);// true
								paani.endsWith("ni"); // false
								paani.includes("aa");// true
								paani.padStart(7, "_");// "_paani "
								paani.padEnd(7, "_");// "paani _"
							</code>
						</pre>
					</section>

					<section>
						<b>Numbers and Math</b>
						<pre class="fragment" data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1|2|4,5,6,7|9,10">
								Number.isSafeInteger(725872159175984159812095198475098314);// false
								Number.isSafeInteger(Math.pow(2, 53) - 1);// true

								Math.sign(-3);// -1
								Math.sign(6);// 1
								Math.sign(-0);// 0
								Math.sign(0);// 0

								// Exponentiation
								console.log(6**4)// 1296 (6 raised to 4)
							</code>
						</pre>
					</section>
				</section>

				<!-- Asynchronous Programming -->
				<section>
					<section>
						<h2>
							Asynchronous Programming
						</h2>
					</section>

					<section>
						<b>Promises</b>
						<pre class="fragment" data-id="code-animation" style="font-size: 18px;">
							<code class="JavaScript" data-trim data-line-numbers="1,2,3,4,5,6,7,8,9,20,11,12,13|14,15,16">
								let p = new Promise((resolve, reject) => {
									setTimeout(() => {
										resolve();
										// or reject();
									});
								});

								p.then((data) => {
									.. on resolve... success ..
								})
								.catch((error) => {
									.. on reject... error ..
								})
								.finally(() => {
									... after either one of then or catch is executed.
								});
							</code>
						</pre>
					</section>

					<section>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1|3,4,5|7,8,9|11-14|16-19">
								let promiseArray = [p1, p2, p3];

								promiseArray.all(() => {
									... after all promises are resolved
								});

								promiseArray.any(() => {
									... after any on of the promises is resolved
								});

								promiseArray.race(() => {
									... after any on of the promises is either resolved or rejected
									i.e. reached their conclusive state
								});

								promiseArray.allSettled(() => {
									... after all promises are either resolved or rejected
									i.e. reached their conclusive state
								});
							</code>
						</pre>
					</section>

					<section>
						<b>Async Await</b>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers>
								const asyncFunc = () => new Promise((resolve) => {
									setTimeout(() => {
										resolve(100);
									}, 1000);
								});
								const res = await asyncFunc();
								console.log(res);// 100 (after 1 sec)
							</code>
						</pre>
					</section>

					<section>
						<b>Then, catch and finally for Async Await</b>
						<pre data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers>
								// awaits cannot be used in top level scope. Hence wrap in an async function.
								(async function () {

									try {
										const resolveValue = await asyncFunc();
										console.log(resolveValue);// 100 (after 1 sec)
									} catch (rejectValue) {
										// error handling
									}
									// everything from here becomes finally
								})();
							</code>
						</pre>
					</section>
				</section>

				<!-- Meta Programming -->
				<section>
					<section>
						<h2>Meta Programming</h2>
					</section>

					<section>
						<b>What is Meta-Programming?</b>
						<ul>
							<li>Ability to read, generate, transform, analyze other programs</li>
							<li class="fragment highlight-green">Ability to modify itself at runtime</li>
						</ul>
					</section>

					<section>
						<b>Parts to Meta-Programming</b>
						<ol>
							<li class="fragment">
								Macros - Can create your own syntax (sweet.js)
								<ul>
									<li class="fragment">Happens during compile time. (Macro-expansion time)</li>
								</ul>
							</li>
							<li class="fragment">
								Reflection
								<ul>
									<li class="fragment">Introspection</li>
									<li class="fragment">Self-Modification</li>
									<li class="fragment">Intercession (Intervening)</li>
								</ul>
							</li>
						</ol>
					</section>

					<section>
						<b>Introspection</b>
						<pre class="fragment" data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1,2,3,4|6,7">
								const adState = {
									visible: true,
									interacted: false,
								};

								const keys = Object.keys(adState);
								// We can kinda "introspect" the object
							</code>
						</pre>
					</section>

					<section>
						<b>Self-Modification</b>
						<pre class="fragment" data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1-9|11,12|13|14">
								function Ad () {
									this.getState = () => {
										// some logic
									};

									this.destroy = () => {
										this.state = () => {return STATE.DISABLED;}
									};
								}

								let ad = new Ad();
								ad.getState();// some state based on logic
								ad.destroy();
								ad.getState(); // DISABLED
							</code>
						</pre>
					</section>

					<section>
						<b>Intercession</b>
						<pre class="fragment" data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1-10|12,13|14|15">
								const adState = {
									visible: true,
									interacted: false,
								};

								Object.defineProperty(adState, 'isDone', {
									get: () => {
										return (this.visible && this.interacted);
									},
								});

								adState.isDone;// false
								adState.interacted = true;
								adState.isDone;// true
								JSON.stringify(adState);// {"visible":true,"interacted":true}
							</code>
						</pre>
					</section>

					<section>
						<b>Why is it usefull?</b>
						<p class="fragment">
							More expressive code.
						</p>
					</section>

					<section>
						<h2>Proxies</h2>
					</section>

					<section>
						<h2>In a backend architecture</h2>
						<img src='./assets/proxy-server.png'>
					</section>
					<section>
						<h2>In JS</h2>
						<img src='./assets/proxy-js.png'>
					</section>

					<section>
						<b>Proxy API - Better Intercession</b>
						<pre class="fragment" data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="|4|5|6|7">
								new Proxy(target, handler);

								// target can be anything
								{}
								[]
								function () {}
								new Proxy(...)
							</code>
						</pre>
					</section>

					<section>
						<b>What does the Handler look like?</b>
						<pre class="fragment" data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers>
								const handler = {
									trap_1: function (target, ...arguements) {},
									trap_2: function (target, ...arguements) {},
									trap_3: function (target, ...arguements) {},
								};
							</code>
						</pre>
					</section>

					<section>
						<h2>Traps</h2>
						<p class="fragment">Traps in this context are methods that provide access to the object in a certain way</p>
						<pre class="fragment" data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1,12|1-5,12|1-12">
								const handler = {
									// get trap
									get: function (target, key) {
										return key in target ? target[key] : "Not Found!";
									},

									// set trap
									set: function (target, key, value) {
										if (isStringSet(value)) {
											target[key] = "proxied_" + value;
										}
									}
								};
							</code>
						</pre>
					</section>

					<section>
						<pre class="fragment" data-id="code-animation">
							<code class="JavaScript" data-trim data-line-numbers="1|1-2|1-3|1-4|1-5|1-6|1-7">
								const impObj = {a:"a"};
								const obj = new Proxy(impObj, handler);
								obj.b = "b";
								console.log(obj.a);// a
								console.log(obj.b);// proxied_b
								obj.a = "a";
								console.log(obj.a);// proxied_a
							</code>
						</pre>
					</section>

					<section>
						<b>Proxies are very powerfull when used with <b class="varcolor">Reflect</b> object</b>
					</section>

					<section>
						<b>Reflect</b>
						<p class="fragment">Reflect is a built-in object that provides methods for interceptable JavaScript operations</p>
						<a class = "fragment" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target = "_blank"><b>Link!</b></a>
					</section>

					<section>
						<h2>No Transpilation available!</h2>
						<img src="./assets/babel-noproxy.png">
					</section>

					<section>
						<b>Use cases?</b>
						<pre class="fragment" data-id="code-animation">
							<code class="typescript" data-trim data-line-numbers>
								const ModuleFactory = {
									getModule: (name) => {.. returns module OR null; }
								};

								interface Module {
									init: () => void;
									getState: () => boolean;
								}
							</code>
						</pre>
					</section>

					<section data-background-iframe="https://es6console.com/" data-background-interactive>
					</section>

					<section>
						<b>For more on Meta-Programming</b><br>
						<a href="https://www.youtube.com/watch?v=_5X2aB_mNp4" target="_blank">
							Eirik Vullum: JavaScript Metaprogramming - ES6 Proxy Use and Abuse | JSConf Budapest 2017
						</a>
						<p>Highly Recommended!</p>
					</section>
				</section>

				<section style="text-align: left;">
					<h1>THE END</h1>
					<ul>
						<li>Presentation made entirely in HTML, CSS and JS!</li>
						<li><a href="https://modern-js-slides.netlify.app/">Netlify App url</a></li>
						<li><a href="https://github.com/rohit-siddhw1/Modern-Javascript-on-the-Browser">Open Sourced at Github</a></li>
						<li><a href="https://github.com/hakimel/reveal.js" target="_blank">Made using reveal.js</a></li>
					</ul>
				</section>

			</div>

		</div>

		<script src="./dist/reveal.js"></script>
		<script src="./plugin/zoom/zoom.js"></script>
		<script src="./plugin/notes/notes.js"></script>
		<script src="./plugin/search/search.js"></script>
		<script src="./plugin/markdown/markdown.js"></script>
		<script src="./plugin/highlight/highlight.js"></script>
		
		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				width: "100%",
				controls: true,
				progress: false,
				center: true,
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
			});

		</script>

	</body>
</html>
